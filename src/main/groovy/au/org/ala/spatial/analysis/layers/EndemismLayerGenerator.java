package au.org.ala.spatial.analysis.layers;


import au.org.ala.layers.intersect.SimpleShapeFile;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.BitSet;
import java.util.Map;

import static java.math.BigDecimal.ROUND_FLOOR;

public class EndemismLayerGenerator extends CalculatedLayerGenerator {

    public EndemismLayerGenerator(BigDecimal resolution, File latLonFile, File shapefileMask, String field) throws IOException {
        super(resolution);

        SimpleShapeFile ssf = null;

        if (shapefileMask != null) {
            ssf = new SimpleShapeFile(shapefileMask.getPath(), field);
        }

        readCoordinateSpeciesFlatFile(latLonFile, false, false, true, true, ssf);
    }

    public static void main(String[] args) throws Exception {
        try {
            if (args.length == 0) {
                System.out.println("args[0]=Resolution in degrees, e.g. 0.1 for 0.1 by 0.1 degree cells\n"
                        + "args[1]=Path to species cell count file (should be generated by biocache store via jenkins - file resolution must match the resolution provided to this tool)\n"
                        + "args[2]=Path to cell species list file (should be generated by biocache store via jenkins - file resolution must match the resolution provided to this tool)\n"
                        + "args[3]=Path of directory in which to write output files\n"
                        + "args[4]=Path to shapefile to use as a mask\n");

                return;
            }

            BigDecimal resolution = new BigDecimal(args[0]).setScale(2, ROUND_FLOOR);
            File latLonFile = new File(args[1]);
            File outputFileDirectory = new File(args[2]);
            String outputFileNamePrefix = args[3];
            File shapefileMask = new File(args[4].replaceAll(".shp", ""));

            new EndemismLayerGenerator(resolution, latLonFile, shapefileMask, "FEATURE").writeGrid(outputFileDirectory, outputFileNamePrefix);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    protected float handleCell(Map.Entry<BigDecimal, BigDecimal> coordPair, float maxValue, PrintWriter ascPrintWriter, BufferedOutputStream divaOutputStream) throws IOException {
        if (_cellSpecies.containsKey(coordPair)) {
            // Calculate endemism value for the cell. Sum (1 / total
            // species cell count) for each species that occurs in
            // the cell. Then divide by the number of species that
            // occur in the cell.

            float endemicityValue = 0;
            BitSet speciesLsids = _cellSpecies.get(coordPair);
            for (int i = 0; i < speciesLsids.length(); i++) {
                if (speciesLsids.get(i)) {
                    int speciesCellCount = _speciesCellCounts.get(i);
                    endemicityValue += 1.0 / speciesCellCount;
                }
            }
            endemicityValue = endemicityValue / speciesLsids.cardinality();

            float newMaxValue = 0;
            if (maxValue < endemicityValue) {
                newMaxValue = endemicityValue;
            } else {
                newMaxValue = maxValue;
            }

            ascPrintWriter.print(endemicityValue);

            ByteBuffer bb = ByteBuffer.wrap(new byte[Float.SIZE / Byte.SIZE]);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            bb.putFloat(endemicityValue);
            divaOutputStream.write(bb.array());

            return newMaxValue;
        } else {
            // No species occurrences in this cell. Endemism value
            // is zero.
            ascPrintWriter.print("0");

            ByteBuffer bb = ByteBuffer.wrap(new byte[Float.SIZE / Byte.SIZE]);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            bb.putFloat(0);
            divaOutputStream.write(bb.array());
            return maxValue;
        }
    }
}
