
SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;

SET search_path = public, pg_catalog;

SET default_with_oids = false;

CREATE TYPE searchobjectstype AS (
    pid character varying,
    id character varying,
    name character varying,
    "desc" character varying,
    fid character varying,
    fieldname character varying
    );


--- FUNCTIONS

-- Function: searchobjects(text, integer)

-- DROP FUNCTION searchobjects(text, integer);

CREATE OR REPLACE FUNCTION searchobjects(q text, lim integer)
  RETURNS SETOF searchobjectstype AS
$BODY$
DECLARE
q2 text;
    strresult text;
found integer;
    r RECORD;
    s RECORD;
BEGIN
    strresult := '';
found := 0;
    IF position('%' in q) > 0 THEN
        q2 := substring(q from 2 for length(q)-2);
ELSE
	q2 := q;
END IF;
FOR r IN SELECT id FROM obj_names WHERE position(q2 in name) > 0 order by position(q2 in name), name LIMIT lim LOOP
        FOR s IN SELECT o.pid as pid, o.id as id, o.name as name, o.desc as desc, o.fid as fid, f.name as fieldname FROM objects o, fields f WHERE o.fid = f.id and o.name_id=r.id LOOP
    RETURN NEXT s;
found := found + 1;
         IF found >= lim THEN
             RETURN;
END IF;
END LOOP;
END LOOP;

    RETURN;
END;
$BODY$
LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER
  COST 10
  ROWS 1000;



-- Function: search_objects_by_geometry_intersect(character varying, geometry)

-- DROP FUNCTION search_objects_by_geometry_intersect(character varying, geometry);

CREATE OR REPLACE FUNCTION search_objects_by_geometry_intersect(IN fidIn character varying, IN geom geometry)
  RETURNS TABLE(pid character varying, id character varying, name character varying, "desc" character varying, fid character varying, bbox character varying, area_km double precision) AS
$BODY$
DECLARE
table_number text;
  id_column_name text;
  object_id text;
  rec RECORD;
BEGIN
SELECT CAST(f.spid AS text) INTO table_number FROM fields f where f.id = fidIn;

-- If a database table for the layer exists (i.e. generated by shp2pgsql) then find matching rows, and then find the ids values for the
-- corresponding rows in the objects table, as defined by the fields table 'sid' value for the layer. This may be more efficient as objects table entries
-- can be complicated combinations of different polygons from a shape that have large bounding boxes.
IF EXISTS (SELECT * FROM pg_tables WHERE tablename = table_number) THEN
SELECT f.sid INTO id_column_name FROM fields f WHERE f.id = fidIn;

IF id_column_name in (SELECT attname FROM pg_attribute WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = quote_ident(table_number))) THEN
		FOR object_id in EXECUTE 'SELECT DISTINCT ' || quote_ident(id_column_name) || ' FROM ' || quote_ident(table_number) || ' t WHERE ST_Intersects(t.the_geom, $1)' USING geom LOOP
			RETURN QUERY EXECUTE 'SELECT o.pid, o.id, o.name, o.desc as description, o.fid, o.bbox, o.area_km FROM objects o WHERE o.fid=' || quote_literal(fidIn) || ' AND o.id=' || quote_literal(object_id);
END LOOP;
ELSE
		-- Otherwise just brute force search all of the objects
		RETURN QUERY EXECUTE 'SELECT o.pid, o.id, o.name, o.desc as description, o.fid, o.bbox, o.area_km FROM objects o WHERE o.fid=' || quote_literal(fidIn) || ' AND ST_Intersects(o.the_geom, $1)' USING geom;
END IF;
ELSE
	  -- Otherwise just brute force search all of the objects
	  RETURN QUERY EXECUTE 'SELECT o.pid, o.id, o.name, o.desc as description, o.fid, o.bbox, o.area_km FROM objects o WHERE o.fid=' || quote_literal(fidIn) || ' AND ST_Intersects(o.the_geom, $1)' USING geom;
END IF;
	RETURN;
END;
$BODY$
LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


-- Function: search_objects_by_location(character varying, double precision, double precision)

-- DROP FUNCTION search_objects_by_location(character varying, double precision, double precision);

CREATE OR REPLACE FUNCTION search_objects_by_location(IN fidIn character varying, IN latitude double precision, IN longitude double precision)
  RETURNS TABLE(pid character varying, id character varying, "desc" character varying, name character varying, fid character varying, the_geom geometry, name_id integer, namesearch boolean, bbox character varying, area_km double precision) AS
$BODY$
DECLARE
table_number text;
  id_column_name text;
  object_id text;
  rec RECORD;
BEGIN
SELECT CAST(f.spid AS text) INTO table_number FROM fields f where f.id = fidIn;

-- If a database table for the layer exists (i.e. generated by shp2pgsql) then find matching rows, and then find the ids values for the
-- corresponding rows in the objects table, as defined by the fields table 'sid' value for the layer. This may be more efficient as objects table entries
-- can be complicated combinations of different polygons from a shape that have large bounding boxes.
IF EXISTS (SELECT * FROM pg_tables WHERE tablename = table_number) THEN
SELECT f.sid INTO id_column_name FROM fields f WHERE f.id = fidIn;
IF id_column_name in (SELECT attname FROM pg_attribute WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = quote_ident(table_number))) THEN
		  FOR object_id in EXECUTE 'SELECT ' || quote_ident(id_column_name) || ' FROM ' || quote_ident(table_number) || ' WHERE ST_Intersects(the_geom, ST_SetSRID(ST_Point(' || longitude || ', ' || latitude || '),4326))' LOOP
	                RAISE NOTICE '%',object_id;
RETURN QUERY EXECUTE 'SELECT * FROM objects o WHERE o.fid=' || quote_literal(fidIn) || ' AND o.id=' || quote_literal(object_id);
END LOOP;
ELSE
	  	  -- Otherwise just brute force search all of the objects
	      RETURN QUERY EXECUTE 'SELECT * FROM objects o WHERE o.fid=' || quote_literal(fidIn) || ' AND ST_Intersects(the_geom, ST_SetSRID(ST_Point(' || longitude || ', ' || latitude || '),4326))';
END IF;
ELSE
	  -- Otherwise just brute force search all of the objects
	  RETURN QUERY EXECUTE 'SELECT * FROM objects o WHERE o.fid=' || quote_literal(fidIn) || ' AND ST_Intersects(the_geom, ST_SetSRID(ST_Point(' || longitude || ', ' || latitude || '),4326))';
END IF;
	RETURN;
END;
$BODY$
LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- CREATE OR REPLACE FUNCTION updateNameSearch()
-- RETURNS bigint AS
--
-- LANGUAGE sql VOLATILE;